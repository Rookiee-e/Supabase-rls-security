# Supabase RLS Vulnerability Catalog

Complete enumeration of RLS security issues for systematic review.

---

## 1. Core RLS Conceptual Problems

| ID | Issue | Risk | Detection |
|----|-------|------|-----------|
| C1 | RLS policies are behavioral, not declarative | Policies execute at runtime; static analysis impossible | Manual review |
| C2 | Policies require mental SQL execution | Easy to misunderstand what a policy actually permits | Trace-based testing |
| C3 | Policy correctness depends on query shape | Same policy, different results with different queries | Query path testing |
| C4 | USING and WITH CHECK confusion | Wrong clause used for wrong operation | Checklist review |
| C5 | Missing WITH CHECK enables escalation | UPDATE without CHECK allows ownership theft | Automated scan |
| C6 | Multiple permissive policies = OR | Unintended access when policies combine | Policy audit |
| C7 | Policy order non-obvious | Depends on system catalog order, not creation | Documentation |
| C8 | RLS failures are silent | No error, just empty results | Adversarial testing |
| C9 | "Looks right" ≠ "is secure" | Pattern matching fails for security | Red team review |
| C10 | Hard to reason without execution | Must test to verify | Required test suites |

---

## 2. Defaults & Configuration Footguns

| ID | Issue | Risk | Detection |
|----|-------|------|-----------|
| D1 | RLS not enabled when expected | New tables default to no RLS | `pg_tables` query |
| D2 | Tables exist without RLS enforced | RLS enabled but not forced | `FORCE ROW LEVEL SECURITY` check |
| D3 | service_role bypasses RLS | Admin key = god mode | Key usage audit |
| D4 | Edge Functions bypass if misused | service_role in functions | Code review |
| D5 | Realtime behaves differently | Subscription filters client-controlled | Realtime policy review |
| D6 | Views may not respect RLS | Depends on owner, security_barrier | View audit |
| D7 | SECURITY DEFINER bypasses RLS | Function runs as owner | Function audit |
| D8 | Policies exist but never execute | Policy for wrong operation type | Policy coverage |
| D9 | Grants override expectations | Direct GRANT bypasses RLS | Grant audit |
| D10 | anon/authenticated confusion | Wrong role in policy | Role testing |

### Detection Query

```sql
-- Find tables without RLS
SELECT schemaname, tablename 
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename NOT IN (
  SELECT tablename FROM pg_tables WHERE rowsecurity = true
);

-- Find SECURITY DEFINER functions
SELECT proname, prosecdef 
FROM pg_proc 
WHERE prosecdef = true;
```

---

## 3. Write Path Vulnerabilities

| ID | Issue | Attack Vector | Mitigation |
|----|-------|---------------|------------|
| W1 | Ownership fields mutable | UPDATE user_id to steal ownership | Immutability trigger |
| W2 | Missing immutability constraints | Attacker changes critical fields | Column-level triggers |
| W3 | INSERT without ownership validation | Insert as any user_id | WITH CHECK on INSERT |
| W4 | UPDATE without WITH CHECK | Modify to gain access | Always include WITH CHECK |
| W5 | Write rows for future read | Poison data for later access | Strict INSERT policies |
| W6 | Poison rows for future access | Set up data for exploit chain | Business logic validation |
| W7 | Foreign keys don't imply authZ | Having FK doesn't mean authorized | Explicit auth checks |
| W8 | Partial updates bypass logic | Update subset of fields | Field-level policies |
| W9 | NULL values bypass predicates | NULL comparison = NULL | `IS NOT NULL` guards |
| W10 | Default values abused | Database defaults exploited | Trigger-based defaults |

### Immutability Trigger Template

```sql
CREATE OR REPLACE FUNCTION enforce_immutable_columns()
RETURNS TRIGGER AS $$
BEGIN
  -- Add each immutable column
  IF OLD.user_id IS DISTINCT FROM NEW.user_id THEN
    RAISE EXCEPTION 'user_id is immutable';
  END IF;
  IF OLD.created_at IS DISTINCT FROM NEW.created_at THEN
    RAISE EXCEPTION 'created_at is immutable';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. Read Path Vulnerabilities

| ID | Issue | Attack Vector | Mitigation |
|----|-------|---------------|------------|
| R1 | Overly permissive SELECT | Broad USING clause | Minimal access principle |
| R2 | Join-based policies leak | Joins expose filtered data | Policy on all joined tables |
| R3 | EXISTS subqueries hide errors | Complex logic obscures bugs | Simplify predicates |
| R4 | LEFT JOIN misunderstood | NULLs from missing joins | Explicit NULL handling |
| R5 | RLS per-row not per-query | Some rows visible, others not | User education |
| R6 | Metadata leakage | Column existence leaked | Minimal error messages |
| R7 | Aggregates reveal info | COUNT(*) leaks presence | Aggregate policies |
| R8 | COUNT/EXISTS side channels | Timing or result differences | Rate limiting |
| R9 | Policy predicates short-circuit | Index-based optimization | Security over performance |
| R10 | Index affects visibility | Partial indexes change results | Careful index design |

---

## 5. Cross-Table & Relationship Issues

| ID | Issue | Attack Vector | Mitigation |
|----|-------|---------------|------------|
| X1 | Auth depends on mutable tables | Modify related table for access | Lock down all auth tables |
| X2 | Membership tables writable | Add self to any team | Strict membership policies |
| X3 | Cascade deletes bypass | Delete parent to affect child | Careful cascade design |
| X4 | Missing FK constraints | Reference non-existent rows | Enforce FK integrity |
| X5 | Orphaned rows readable | Delete parent, child exposed | Handle orphans in policy |
| X6 | Inconsistent ownership | user_id means different things | Standardize ownership |
| X7 | Cyclic dependencies | A→B→A policy loops | Avoid circular auth |
| X8 | Deep join chains unreviewable | 5-table join auth | Simplify auth structure |
| X9 | Policies depend on app invariants | App bug = security bug | DB-enforced invariants |
| X10 | Cross-schema confusion | public vs auth schema | Schema-qualified references |

---

## 6. JWT & Auth Claim Problems

| ID | Issue | Attack Vector | Mitigation |
|----|-------|---------------|------------|
| J1 | JWT claims trusted too much | Stale claims exploited | DB state verification |
| J2 | Claims become stale | Revoked user still has token | Short expiry + refresh |
| J3 | Role claims drift | DB role changed, JWT same | Always check DB |
| J4 | auth.uid() vs JWT sub confusion | Wrong function used | Standardize on auth.uid() |
| J5 | Multiple identity representations | UUID vs email vs username | Single canonical ID |
| J6 | Custom claims increase surface | More claims = more bugs | Minimal claims |
| J7 | JWT size limits | Overloading claims | Keep JWT small |
| J8 | Claim-based authZ hard to revoke | Can't invalidate claims | DB-based authorization |
| J9 | Time-based access fragile | Clock skew exploits | Server-side time checks |
| J10 | Assumed claim presence | Missing claim = crash | Null-safe claim access |

### Secure Claim Access

```sql
-- UNSAFE
(auth.jwt() ->> 'role') = 'admin'

-- SAFE - always verify against DB
EXISTS (
  SELECT 1 FROM user_roles 
  WHERE user_id = auth.uid() 
  AND role = 'admin' 
  AND expires_at > now()
)
```

---

## 7. Role & Permission Misuse

| ID | Issue | Attack Vector | Mitigation |
|----|-------|---------------|------------|
| P1 | Overloading authenticated role | All users same permissions | Custom roles per permission |
| P2 | Roles imply permissions | Role present ≠ authorized | Explicit permission checks |
| P3 | Admin logic in policies | Complex admin checks | Separate admin policies |
| P4 | Mixing authZ and authN | Authentication ≠ authorization | Clear separation |
| P5 | Multiple roles mishandled | User with roles A+B | Role composition testing |
| P6 | Temporary roles unsafe | Time-limited not enforced | Expiry in DB |
| P7 | Soft-deleted roles grant access | deleted_at not checked | Include deleted check |
| P8 | Role hierarchy incorrect | Parent roles don't inherit | Explicit hierarchy |
| P9 | Permission drift | Roles change over time | Regular audits |
| P10 | No single source of truth | Roles in JWT and DB | DB as source of truth |

---

## 8. LLM-Specific Failure Modes

| ID | Issue | Example | Prevention |
|----|-------|---------|------------|
| L1 | Confidently wrong policies | Correct syntax, wrong logic | Human review required |
| L2 | Pattern-matched examples | Copy unsuitable patterns | Context-aware generation |
| L3 | Outdated APIs suggested | Old Supabase syntax | Check current docs |
| L4 | USING/WITH CHECK mistakes | Wrong clause for operation | Checklist enforcement |
| L5 | Missing edge cases | Happy path only | Adversarial test requirement |
| L6 | Incorrect immutability assumptions | Assumes fields locked | Explicit trigger generation |
| L7 | Joins without threat modeling | Insecure join auth | Require threat analysis |
| L8 | Hallucinated "best practices" | Made-up security patterns | Verify all patterns |
| L9 | No adversarial reasoning | No attack simulation | Required attack scenarios |
| L10 | No execution simulation | Doesn't trace paths | Required trace documentation |

---

## 9. Testing & Verification Gaps

| ID | Gap | Required Test |
|----|-----|---------------|
| T1 | No adversarial test cases | Attack scenario tests |
| T2 | Only happy-path testing | Failure path tests |
| T3 | No role switching | Multi-role test users |
| T4 | No impersonation testing | Test as different users |
| T5 | No update/insert abuse tests | Privilege escalation tests |
| T6 | No downgrade tests | Permission removal tests |
| T7 | No policy coverage metrics | Coverage reporting |
| T8 | No CI enforcement | Automated policy tests |
| T9 | Manual testing doesn't scale | Automated test suite |
| T10 | False sense of security | Regular security audits |

### Test Template

```sql
-- Setup test users
INSERT INTO auth.users (id) VALUES 
  ('user-a-uuid'),
  ('user-b-uuid'),
  ('admin-uuid');

-- Test 1: User A cannot read User B's data
SET LOCAL request.jwt.claims = '{"sub": "user-a-uuid"}';
SELECT count(*) FROM documents WHERE user_id = 'user-b-uuid';
-- Expected: 0

-- Test 2: User A cannot UPDATE to become User B
UPDATE documents SET user_id = 'user-a-uuid' WHERE user_id = 'user-b-uuid';
-- Expected: 0 rows affected or error

-- Test 3: User A cannot INSERT as User B
INSERT INTO documents (user_id, content) VALUES ('user-b-uuid', 'test');
-- Expected: error
```

---

## 10. Performance & Optimization Side Effects

| ID | Issue | Security Impact | Mitigation |
|----|-------|-----------------|------------|
| O1 | Indexes affect behavior | Partial indexes change visibility | Security-aware indexing |
| O2 | Query planner changes results | Optimization changes access | Stable policy design |
| O3 | Policy complexity hurts perf | Pressure to simplify = weaken | Security over speed |
| O4 | Performance fixes weaken security | Caching bypasses checks | Explicit cache policies |
| O5 | Caching interacts with RLS | Stale authorized data | Per-user cache keys |
| O6 | Realtime performance shortcuts | Subscription filters loose | Strict realtime policies |
| O7 | Denormalization risks | Redundant data inconsistent | Trigger-based sync |
| O8 | Materialized views bypass | MVs not subject to RLS | Secure refresh patterns |
| O9 | Optimization breaks assumptions | Inlining changes semantics | Test after optimization |
| O10 | Security sacrificed for speed | "Just for production" | Never compromise |

---

## 11. Organizational / Human Problems

| ID | Issue | Mitigation |
|----|-------|------------|
| H1 | Policies never revisited | Scheduled security reviews |
| H2 | Security knowledge siloed | Documentation, training |
| H3 | Copy-paste from blogs | Vet all external patterns |
| H4 | No formal threat model | Required threat modeling |
| H5 | No ownership of authZ logic | Designated security owner |
| H6 | Reviews focus on functionality | Security-focused reviews |
| H7 | "Supabase handles security" myth | Education on shared responsibility |
| H8 | Overconfidence in RLS | Regular penetration testing |
| H9 | Time pressure = shortcuts | Security as non-negotiable |
| H10 | Lack of security literacy | Training programs |

---

## 12. Structural Limitations of Supabase RLS

| ID | Limitation | Workaround |
|----|------------|------------|
| S1 | RLS not a policy language | Treat as low-level primitive |
| S2 | No static analysis tooling | Custom audit scripts |
| S3 | No formal verification | Manual proof of correctness |
| S4 | No composition guarantees | Document policy interactions |
| S5 | No audit trails for decisions | Application-level logging |
| S6 | No "deny" semantics | Use RESTRICTIVE policies |
| S7 | No visibility into evaluation | EXPLAIN ANALYZE with RLS |
| S8 | Hard to reason at scale | Limit policy count |
| S9 | Not suited for complex workflows | Hybrid with app logic |
| S10 | Easy to misuse correctly-looking code | Rigorous review process |

---

## Quick Reference: Red Flags

Immediately investigate if you see:

```sql
-- Red flags in policies
WITH CHECK (true)
USING (true)
USING (1=1)
FOR ALL  -- without specific checks
SECURITY DEFINER  -- without manual auth

-- Red flags in schema
-- Missing triggers on ownership columns
-- No FORCE ROW LEVEL SECURITY
-- Public grants on sensitive tables
-- SECURITY DEFINER functions without auth checks
```

---

## Audit Query Collection

```sql
-- 1. Tables without RLS
SELECT tablename FROM pg_tables 
WHERE schemaname = 'public' AND NOT rowsecurity;

-- 2. Tables with RLS but not forced
SELECT tablename FROM pg_tables 
WHERE schemaname = 'public' AND rowsecurity = true
AND tablename NOT IN (
  SELECT tablename FROM pg_class c
  JOIN pg_namespace n ON c.relnamespace = n.oid
  WHERE n.nspname = 'public' AND c.relforcerowsecurity = true
);

-- 3. Policies without WITH CHECK
SELECT tablename, policyname 
FROM pg_policies 
WHERE cmd IN ('INSERT', 'UPDATE') AND with_check IS NULL;

-- 4. SECURITY DEFINER functions
SELECT proname FROM pg_proc 
JOIN pg_namespace ON pg_proc.pronamespace = pg_namespace.oid
WHERE nspname = 'public' AND prosecdef = true;

-- 5. Overly permissive policies
SELECT tablename, policyname, qual 
FROM pg_policies 
WHERE qual::text LIKE '%true%';
```
